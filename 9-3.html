<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600638 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1639"/>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>作者：</b></td><td><i>849040099@qq.com</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><p style="line-height: 1.5; margin: 10px auto; text-indent: 0px; color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;">volatile</span></div><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;">java虚拟机提供的轻量级的同步机制</span></div><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;"><br/></span></div><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;">线程中被volatile标识的变量</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 14.0pt; font-family: Lato; mso-fareast-font-family: Lato; mso-bidi-font-family: Lato; color: #555555;-en-paragraph:true;">线程解锁前，必须把共享变量的值刷新回主内存</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 14.0pt; font-family: Lato; mso-fareast-font-family: Lato; mso-bidi-font-family: Lato; color: #555555;-en-paragraph:true;">线程加锁前，必须读取主内存的最新值到自己的工作内存</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 14.0pt; font-family: Lato; mso-fareast-font-family: Lato; mso-bidi-font-family: Lato; color: #555555;-en-paragraph:true;">加锁解锁是同一把锁</span></div><div style="margin-top: 1em; margin-bottom: 1em;">也就是每次变量修改后会写入主存中</div><div style="margin-top: 1em; margin-bottom: 1em;">在使用此变量时也是先从主存中拷贝到自己的内存中</div><hr/><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;">线程池：</span></div><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;">作用：减少资源浪费</span></div><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;">种类：单线程池、固定（定长）、缓存、周期</span></div><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;">工作原理： </span></div><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;"><span>    </span><span>    </span>1、工作线程数如果小于核心线程数就执行线程</span></div><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;">        2、当工作线程数大于等于核心线程数加入到队列</span></div><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;">        3、当队列满了工作线程数如果小于最大线程数执行线程</span></div><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;">        4、当队列满了工作线程数如果大于等于最大线程数 执行拒绝策略</span></div><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;">        5、拒绝策略： 默认情况抛出异常、从队列中舍去一个然后执行、什么都不做、直接执行</span></div><div><span style="color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;; font-size: 18pt;"><br/></span></div><div><span style="color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;; font-size: 18pt;">单： 只用唯一一个工作线程执行按照指定顺序执行（fifo,lifo,优先级）</span></div><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;">固：设置线程总数；如果加入的工作线程多于设置的线程总数，只会执行设置的线程数的线程</span></div><div><span style="font-size: 18pt; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;;">缓：不限制线程的数量，如果上一次的线程执行完毕会重用上一次的线程</span></div><hr/><div><span style="color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;; font-size: 18pt;">sleep和wait的区别</span></div><div><span style="color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;; font-size: 18pt;">sleep不释放锁 唤醒后继续执行</span></div><div><span style="color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;; font-size: 18pt;">wait释放锁被唤醒后不会立即执行而是加入cpu争抢线程之中</span></div><hr/><div><span style="font-weight: bold; font-size: 18pt;">线程的3中实现方式：    </span></div><div><span style="font-weight: bold; font-size: 18pt;">    1、继承Thread                        缺点java只能单继承但可以多实现</span></div><div><span style="font-weight: bold; font-size: 18pt;">    2、实现Runable                      优点多实现</span></div><div><span style="font-weight: bold; font-size: 18pt;">    3、</span><span style="font-size: 18pt;"><span style="font-size: 18pt; font-weight: bold;">实现Callable和Future        有点多实现有返回值</span></span></div><div><span style="font-size: 18pt;"><br/></span></div><hr/><div><span style="font-weight: bold; font-size: 18pt;">关于wati被唤醒后在哪里执行</span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(54, 46, 43); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">在Java对象中，有两种池 </span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(54, 46, 43); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">琐池-----------------------synchronized </span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(54, 46, 43); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">等待池---------------------wait(),notify(),notifyAll() </span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(54, 46, 43); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">如果一个线程调用了某个对象的wait方法，那么该线程进入到该对象的等待池中(并且已经将锁释放)， </span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(54, 46, 43); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">如果未来的某一时刻，另外一个线程调用了相同对象的notify方法或者notifyAll方法， </span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(54, 46, 43); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">那么该等待池中的线程就会被唤起，然后进入到对象的锁池里面去获得该对象的锁， </span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(54, 46, 43); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">如果获得锁成功后，那么该线程就会</span><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">沿着wait方法之后</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(54, 46, 43); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">的路径继续执行。注意是</span><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(54, 46, 43); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">沿着wait方法之后</span></div><div><span style="font-size: 18pt;"><span style="font-size: 18pt; font-weight: bold;">答：沿着wait之后的方法继续执行</span></span></div><div><br/></div><hr/><div><br/></div><div><br/></div><div><span style="font-weight: bold;">1、新建状态</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">用new Thread()建立一个线程对象后，该线程对象就处于新生状态。</span></div><p style="line-height: 1.5; margin: 10px auto; text-indent: 0px; color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div><br/></div><div><span style="font-weight: bold;">2、就绪状态</span></div><div>通过调用线程的start方法进入就绪状态（runnable）。注意：不能对已经启动的线程再次调用start()方法，否则会出现Java.lang.IllegalThreadStateException异常。</div><div>处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（就绪池），等待系统为其分配CPU。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">Note：如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠一伙儿，转去执行子线程。</span></div><p style="line-height: 1.5; margin: 10px auto; text-indent: 0px; color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div><br/></div><div><span style="font-weight: bold;">3、运行状态</span></div><div>处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</div><div>处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。</div><div>如果该线程失去了cpu资源，就会又从运行状态变为就绪状态，重新等待系统分配资源。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。</span></div><p style="line-height: 1.5; margin: 10px auto; text-indent: 0px; color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div><br/></div><div><span style="font-weight: bold;">4、阻塞状态</span></div><div>当发生如下情况时，线程会让出CPU控制权并暂时停止自己的运行，从运行状态变为阻塞状态：</div><div>① 线程调用sleep方法主动释放CPU控制权</div><div>② 线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞</div><div>③ 线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有</div><div>④ 线程在等待某个通知（notify）</div><div>⑤ 程序调用了线程的suspend方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。</div><div>在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">当发生如下情况时，线程会从运行状态变为阻塞状态：</span></div><p style="line-height: 1.5; margin: 10px auto; text-indent: 0px; color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div><br/></div><div><span style="font-weight: bold;">5、死亡状态</span></div><div>当线程的run()方法执行完，或者被强制性地终止，例如出现异常，或者调用了stop()、desyory()方法等等，就会从运行状态转变为死亡状态。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;"> </span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5; font-weight: bold;">Note:</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">1. sleep() 是Thread的静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;"> </span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">2. Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。</span></div><p style="line-height: 1.5; margin: 10px auto; text-indent: 0px; color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div>但是不管程序员怎么编写调度，<span style="font-weight: bold;">只能最大限度的影响线程执行的次序，而不能做到精准控制</span>。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;"> </span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">3. yield()方法</span></div><p style="line-height: 1.5; margin: 10px auto; text-indent: 0px; color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div>yield()方法和sleep()方法有点相似，也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出cpu资源给其他的线程。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="color: rgb(255, 0, 255); line-height: 1.5;-en-paragraph:true;">但是和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;"> </span></div><p style="line-height: 1.5; margin: 10px auto; text-indent: 0px; color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div>4. join()方法，<span style="font-weight: bold;">线程合并</span></div><div>线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时，Thread类提供了join方法来完成这个功能，注意，它不是静态方法。</div><div>从上面的方法的列表可以看到，它有3个重载的方法：</div><div>void join()    </div><div>    <span style="color: rgb(0, 0, 0); line-height: 1.5;">当前线程等待</span>加入该线程后面，等待该线程终止。即，等待该线程执行完毕后再执行当前线程。    </div><div>void join(long millis)    </div><div>    当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度   </div><div>void join(long millis,int nanos)    </div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">    等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度  </span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;"> </span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">5. </span><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5; font-weight: bold;">守护线程</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">守护线程与普通线程写法上基本么啥区别，调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。</span></div><p style="line-height: 1.5; margin: 10px auto; text-indent: 0px; color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div>setDaemon方法的详细说明：</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">public final void setDaemon(boolean on)将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。</span><span style="color: rgb(0, 0, 255); line-height: 1.5;-en-paragraph:true;">该方法必须在启动线程前调用。</span><span style="-en-paragraph:true;"> </span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">实际上：</span><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 255); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程（守护线程）时候一定要注意这个问题</span><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">。</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5; font-weight: bold;">守护线的好处就是你不需要关心它的结束问题。</span><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;"> </span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">6. </span><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5; font-weight: bold;">如何结束一个线程</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">想要安全有效的结束一个线程，只要保证在一定的情况下，run方法能够执行完毕即可。而不是while(true)的无线循环。</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">有些时候线程的run()方法不能正常的执行完毕（可能在运行时转成了阻塞），这种情况下可以借助Thread对象的interrupt()方法将中断状态设置为true来结束一个线程。</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">当一个线程处于sleep、wait、join这三种状态之一的时候，如果此时他的中断状态为true，那么它就会抛出一个InterruptedException的异常，并将中断状态重新设置为false。</span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;"> </span></div><div style="margin: 10px auto; text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">我们看看sleep、wait、join方法的声明：</span></div><div style="font-size: 12px; overflow: auto; word-break: break-word; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); margin: 18px 0px !important;"><div style="background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); padding: 5px; overflow: auto; margin: 5px 0px; font-size: 12px !important;"><div style="margin-top: 0px; margin-bottom: 0px; white-space: pre-wrap; overflow-wrap: break-word; font-size: 12px !important;"><div><span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">public</span> <span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">final</span> <span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">void</span> <span style="color: rgb(0, 0, 0); font-family: &quot;Courier New&quot;; font-size: 12px; font-variant-caps: normal; font-variant-ligatures: normal;">wait()</span> <span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">throws</span> <span style="font-size: 12px; color: rgb(0, 0, 0); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">InterruptedException</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">public</span> <span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">static</span> <span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">native</span> <span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">void</span> <span style="color: rgb(0, 0, 0); font-family: &quot;Courier New&quot;; font-size: 12px; font-variant-caps: normal; font-variant-ligatures: normal;">sleep(</span><span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">long</span> <span style="color: rgb(0, 0, 0); font-family: &quot;Courier New&quot;; font-size: 12px; font-variant-caps: normal; font-variant-ligatures: normal;">millis)</span> <span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">throws</span> <span style="font-size: 12px; color: rgb(0, 0, 0); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">InterruptedException</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">public</span> <span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">final</span> <span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">void</span> <span style="color: rgb(0, 0, 0); font-family: &quot;Courier New&quot;; font-size: 12px; font-variant-caps: normal; font-variant-ligatures: normal;">join()</span> <span style="font-size: 12px; color: rgb(0, 0, 255); font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">throws</span> <span style="color: rgb(0, 0, 0); font-family: &quot;Courier New&quot;; font-size: 12px; font-variant-caps: normal; font-variant-ligatures: normal;">InterruptedException</span></div></div></div><div style="margin: 10px auto; text-indent: 0px;"><span style="text-indent: 0px; color: rgb(0, 102, 153); font-family: Consolas, &quot;Courier New&quot;, Courier, mono, serif; font-size: 12px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5; font-weight: bold;">可以看到，这三者有一个共同点，都抛出了一个InterruptedException的异常。所以，我们可以使用interrupt这个巧妙的方式结束掉这种情况下的线程。</span></div></div><div><br/></div></div><div><br/></div></span>
</div>
<hr>
<a name="1655"/>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>作者：</b></td><td><i>849040099@qq.com</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><img src="9-3_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><font style="font-size: 18pt;">error 比较严重 不能被捕获和处理<br/></font></div><div><font style="font-size: 18pt;">exception 没有error严重 可以捕获和处理</font></div><div><font style="font-size: 18pt;"><br/></font></div><div><font style="font-size: 18pt;">error一般都是内存级别的问题</font></div><div><font style="font-size: 18pt;"><br/></font></div><div><font style="font-size: 18pt;">exception 分为运行时和检查 </font></div><div><span style="font-size: 18pt;"><br/></span></div><div><span style="font-size: 18pt;">运行时就是编译可以通过但是运行时不符合规范造成的</span></div><div><span style="font-size: 18pt;">检查时就是在你编译时就不通过必须try cath</span></div><div><span style="font-size: 18pt;"><br/></span></div><div><span style="font-size: 18pt;">throw 与throws</span></div><div><span style="font-size: 18pt;">throw 是直接抛出一个异常  出现在函数体内</span></div><div><span style="font-size: 18pt;">throws 是可能出现的异常 <span>    </span>出现在方法头上</span></div><div><font style="font-size: 18pt;"><br/></font></div><div><span style="font-size: 18pt;">一般开发中处理异常都是自己封装的异常对象然后抛出相关提示</span></div><div><span style="font-size: 18pt;">1、为了让客户能看懂</span></div><div><span style="font-size: 18pt;">2、解决代码冗余</span></div><div><font style="font-size: 18pt;"><br/></font></div><div><font style="font-size: 18pt;"><br/></font></div></span>
</div></body></html> 